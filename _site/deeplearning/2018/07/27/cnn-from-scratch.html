<!DOCTYPE html><html lang="VI">
  <head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"><title>Convolutional Neural Network from scratch - the INFINITY.</title>

<meta name="description" content="Convolutional Neural NetworkNeural Network ra đời là một bước đột phá lớn của giới khoa học máy tính và mở ra một tìm năng cho các bài toán nhận dạng. Tuy nh...">
<link rel="canonical" href="http://localhost:4000/deeplearning/2018/07/27/cnn-from-scratch.html"><link rel="alternate" type="application/rss+xml" title="the INFINITY." href="/feed.xml">
<!-- begin favicon --><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png"><link rel="manifest" href="/assets/site.webmanifest"><link rel="mask-icon" href="/assets/safari-pinned-tab.svg" color="#fc4d50"><link rel="shortcut icon" href="/assets/favicon.ico">

<meta name="msapplication-TileColor" content="#ffc40d"><meta name="msapplication-config" content="/assets/browserconfig.xml">

<meta name="theme-color" content="#ffffff">
<!-- end favicon --><link rel="stylesheet" href="/assets/css/main.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" >
<script>(function() {
  window.isArray = function(val) {
    return Object.prototype.toString.call(val) === '[object Array]';
  };
  window.isString = function(val) {
    return typeof val === 'string';
  };

  window.decodeUrl = function(str) {
    return str ? decodeURIComponent(str.replace(/\+/g, '%20')) : '';
  };


  window.hasEvent = function(event) {
    return 'on'.concat(event) in window.document;
  };

  window.isOverallScroller = function(node) {
    return node === document.documentElement || node === document.body || node === window;
  };

  window.pageLoad = (function () {
    var loaded = false, cbs = [];
    window.addEventListener('load', function () {
      var i, cb; loaded = true;
      if (cbs.length > 0) {
        for (i = 0; i < cbs.length; i++) {
          cb = cbs[i]; cb();
        }
      }
    });
    return {
      then: function(cb) {
        cb && (loaded ? cb() : (cbs.push(cb)));
      }
    };
  })();
})();(function() {
  window.throttle = function(func, wait) {
    var args, result, thisArg, timeoutId, lastCalled = 0;

    function trailingCall() {
      lastCalled = new Date;
      timeoutId = null;
      result = func.apply(thisArg, args);
    }
    return function() {
      var now = new Date,
        remaining = wait - (now - lastCalled);

      args = arguments;
      thisArg = this;

      if (remaining <= 0) {
        clearTimeout(timeoutId);
        timeoutId = null;
        lastCalled = now;
        result = func.apply(thisArg, args);
      } else if (!timeoutId) {
        timeoutId = setTimeout(trailingCall, remaining);
      }
      return result;
    };
  };
})();(function() {
  var Set = (function() {
    var add = function(item) {
      var i, data = this._data;
      for (i = 0; i < data.length; i++) {
        if (data[i] === item) {
          return;
        }
      }
      this.size ++;
      data.push(item);
      return data;
    };

    var Set = function(data) {
      this.size = 0;
      this._data = [];
      var i;
      if (data.length > 0) {
        for (i = 0; i < data.length; i++) {
          add.call(this, data[i]);
        }
      }
    };
    Set.prototype.add = add;
    Set.prototype.get = function(index) { return this._data[index]; };
    Set.prototype.has = function(item) {
      var i, data = this._data;
      for (i = 0; i < data.length; i++) {
        if (this.get(i) === item) {
          return true;
        }
      }
      return false;
    };
    Set.prototype.is = function(map) {
      if (map._data.length !== this._data.length) { return false; }
      var i, j, flag, tData = this._data, mData = map._data;
      for (i = 0; i < tData.length; i++) {
        for (flag = false, j = 0; j < mData.length; j++) {
          if (tData[i] === mData[j]) {
            flag = true;
            break;
          }
        }
        if (!flag) { return false; }
      }
      return true;
    };
    Set.prototype.values = function() {
      return this._data;
    };
    return Set;
  })();

  window.Lazyload = (function(doc) {
    var queue = {js: [], css: []}, sources = {js: {}, css: {}}, context = this;
    var createNode = function(name, attrs) {
      var node = doc.createElement(name), attr;
      for (attr in attrs) {
        if (attrs.hasOwnProperty(attr)) {
          node.setAttribute(attr, attrs[attr]);
        }
      }
      return node;
    };
    var end = function(type, url) {
      var s, q, qi, cbs, i, j, cur, val, flag;
      if (type === 'js' || type ==='css') {
        s = sources[type], q = queue[type];
        s[url] = true;
        for (i = 0; i < q.length; i++) {
          cur = q[i];
          if (cur.urls.has(url)) {
            qi = cur, val = qi.urls.values();
            qi && (cbs = qi.callbacks);
            for (flag = true, j = 0; j < val.length; j++) {
              cur = val[j];
              if (!s[cur]) {
                flag = false;
              }
            }
            if (flag && cbs && cbs.length > 0) {
              for (j = 0; j < cbs.length; j++) {
                cbs[j].call(context);
              }
              qi.load = true;
            }
          }
        }
      }
    };
    var load = function(type, urls, callback) {
      var s, q, qi, node, i, cur,
        _urls = typeof urls === 'string' ? new Set([urls]) : new Set(urls), val, url;
      if (type === 'js' || type ==='css') {
        s = sources[type], q = queue[type];
        for (i = 0; i < q.length; i++) {
          cur = q[i];
          if (_urls.is(cur.urls)) {
            qi = cur;
            break;
          }
        }
        val = _urls.values();
        if (qi) {
          callback && (qi.load || qi.callbacks.push(callback));
          callback && (qi.load && callback());
        } else {
          q.push({
            urls: _urls,
            callbacks: callback ? [callback] : [],
            load: false
          });
          for (i = 0; i < val.length; i++) {
            node = null, url = val[i];
            if (s[url] === undefined) {
              (type === 'js' ) && (node = createNode('script', { src: url }));
              (type === 'css') && (node = createNode('link', { rel: 'stylesheet', href: url }));
              if (node) {
                node.onload = (function(type, url) {
                  return function() {
                    end(type, url);
                  };
                })(type, url);
                (doc.head || doc.body).appendChild(node);
                s[url] = false;
              }
            }
          }
        }
      }
    };
    return {
      js: function(url, callback) {
        load('js', url, callback);
      },
      css: function(url, callback) {
        load('css', url, callback);
      }
    };
  })(this.document);
})();</script><script>
  (function() {
    var TEXT_VARIABLES = {
      version: '2.2.0',
      sources: {
        font_awesome: 'https://use.fontawesome.com/releases/v5.0.13/css/all.css',
        jquery: 'https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js',
        leancloud_js_sdk: '//cdn1.lncld.net/static/js/3.4.1/av-min.js',
        chart: 'https://cdn.bootcss.com/Chart.js/2.7.2/Chart.bundle.min.js',
        gitalk: {
          js: 'https://cdn.bootcss.com/gitalk/1.2.2/gitalk.min.js',
          css: 'https://cdn.bootcss.com/gitalk/1.2.2/gitalk.min.css'
        },
        mathjax: 'https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML',
        mermaid: 'https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js'
      },
      site: {
        toc: {
          selectors: 'h1,h2,h3'
        }
      },
      paths: {
        search_js: '/assets/search.js'
      }
    };
    window.TEXT_VARIABLES = TEXT_VARIABLES;
  })();
</script></head>
  <body>
    <div class="root" data-is-touch="false">
      <script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 45,
  backgroundColor: 'rgb(10, 10, 10)',
  textColor: '#fff'
})</script><div class="layout--page js-page-root"><div class="page__main js-page-main has-aside">

    <div class="page__main-inner">
      <div></div><div class="page__header"><header class="header"><div class="main">
      <div class="header__title">
        <div class="header__brand"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="24px" height="24px" viewBox="0 0 24 24">
<style type="text/css">
	.st0{fill:#515151;}
</style>
<path class="st0" d="M1.7,22.3c5.7-5.7,11.3-5.7,17,0c3.3-3.3,3.5-5.3,0.8-6c2.7,0.7,3.5-1.1,2.3-5.6s-3.3-5.2-6.3-2.1
	c3-3,2.3-5.2-2.1-6.3S7,1.8,7.7,4.6C7,1.8,5,2.1,1.7,5.3C7.3,11,7.3,16.7,1.7,22.3"/>
</svg><a title="A person who never made a mistake never try anything new.
" href="/">the INFINITY.</a></div>
        <button class="button button--secondary button--circle search-button js-search-toggle"><i class="fas fa-search"></i></button>
      </div><nav class="navigation">
        <ul><li class="navigation__link"><a href="/archive.html">Archive</a></li><li class="navigation__link"><a href="/about.html">About</a></li><li><button class="button button--secondary button--circle search-button js-search-toggle"><i class="fas fa-search"></i></button></li>
        </ul>
      </nav></div>
  </header>
</div><div class="page__content"><div class ="main"><div class="grid grid--reverse">

             <div class="col-aside js-col-aside"><aside class="page__aside js-page-aside"><div class="toc-aside js-toc-root"></div></aside></div>

            <div class="col-main cell--auto"><article itemscope itemtype="http://schema.org/Article"><div class="article__header"><header><h1>Convolutional Neural Network from scratch</h1></header><span class="split-space">&nbsp;</span>
          <a class="edit-on-github"
            title="Edit on Github"
            href="https://github.com/vndee/vndee.github.io/tree/master/_posts/2018-07-27-cnn-from-scratch.md">
            <i class="far fa-edit"></i></a></div><meta itemprop="headline" content="Convolutional Neural Network from scratch"><div class="article__info clearfix"><ul class="left-col menu"><li>
              <a class="button button--secondary button--pill button--sm"
                href="/archive.html?tag=deep-learning">deep-learning</a>
            </li></ul><ul class="right-col menu"><li><i class="fas fa-user"></i> <span>Duy V. Huynh</span></li><li><i class="far fa-calendar-alt"></i> <span>Jul 27, 2018</span>
            </li></ul></div><meta itemprop="author" content="Duy V. Huynh"/><meta itemprop="datePublished" content="2018-07-27T02:57:18+07:00">
    <meta itemprop="keywords" content="deep-learning"><div class="js-article-content"><div class="layout--article">

  <div class="article__content" itemprop="articleBody"><h2 id="convolutional-neural-network">Convolutional Neural Network</h2>
<p><img src="https://lh3.googleusercontent.com/lPExPbUljLjBXEIQd54kyVFZ4Z36sFAXSPfI9H-RMX81qn83Vl-R7-fMT60p2PhVa0RjnEJBLwaWuqvL4TT0i8Og_QvhR3RbK6xxOIxrfijD2FXc5Nfzo8QODOu0hWlRZUk8tq7xxGfOasHsLdOfCXtTAu1D_ifAZPXF_-Ds-k1FOk9GlR5Dkkwan57wzM7Nvet1O084FpTwg49ihxEUM-gwuTwizKgrWSgfWiMpS4YvuBHenSFglbqZj66ENde_xhsKPjeb2Y49FYxeJGFcLNumOje692tSqInQLbQapVnVv6SLlER-up42jUIjYvdypmIoxZfMauTyC3RwYeohiAklISIQW0wrDAg2A552P8koG_NBpVJwgqiBRHtCXRwS2KxaHZvrXWBzPhyz_ulRTeyxOVpbuYkw7EKn3t9Gc4g0RC4-9CUbnaf49Wc3dWd6bp9ifcBXr3jQFEwQ66ACyFgVzeo45RgZje64t6B8v_lBcF1o3DFfgqzRBGhyKoS60Ji1yRnAv23Ln2ptXSB_vHSOHnaJtALY3Nb3vUPuSpBTlWL_ivb369wfz9TULcJ9bwSdoplGii5YrGN0Kv1o9xrS7uJHFrzGm0BxBu7NpatXV3OjRQNUJcEAA8hYY4f-H6xnlWS7OSO8iHo8jY1OakjASPd2HZ_R=w748-h279-no" alt="Intro" />
Neural Network ra đời là một bước đột phá lớn của giới khoa học máy tính và mở ra một tìm năng cho các bài toán nhận dạng. Tuy nhiên với những bài toán có dữ liệu đầu vào là hình ảnh thì việc sử dụng mô hình mạng Neural Network truyền thống còn gặp phải nhiều hạn chế. Do đó CNN (Convolutional Neural Network) đã ra đời và trở thành một trong những phương pháp chính để giải quyết các bài toán nhận dạng và phân loại không những trong lĩnh vực thị giác máy tính (Computer Vision) mà còn ở các bài toán về xử lí ngôn ngữ tự nhiên (Natural Language Processing).</p>

<h2 id="kiến-trúc-lenet-1990s">Kiến trúc LeNet (1990s)</h2>

<p>LeNet là một trong những kiến trúc CNN đầu tiên được đề xuất bởi <a href="http://yann.lecun.com/">Yan LeCun</a> sau một loạt các thành công về nghiên cứu bắt đầu từ thập niên 90 của thế kỉ trước.
<img src="https://lh3.googleusercontent.com/VXTODFaGAK3HP4uX5WRzxOkzCSKZkDX9XQB6w7ReQzzD1SwPpSjp39tdvHxCZdT4M3pPM-17vDzLwfxfxsISiqOfnns-kltgnHy_cF5fCEPinbmJ-GEUiUAhaMT0Pxie4Da6Mm4yt-u48FNkYCkhqDx5V1EwJso9CCX6XEfZfXf7jLmzx1MPu76Z4Kd90clwsEHRTDNyCk6Iesbe2Xb5u96gw4GOQz-H2GcNb3SLP8tCTIIx6LESIPfuyYB1GTxug5bJlLtV_6_Pm_8L-N-F1mPbbUGhL4nKAWOGtjQrxDlRha4L0i_6kPjpGcsg_xAD6AUFqTDT7Qr_B5FjYsCIK9bNiGx_StQf06SLfBsh7N29UugWZ2zeXvglGjmCoWzEyua6VeikipznQTSAqntDQs14oFlSYtLUu1jA98OAPl68s3VULBinkLUvQoZjQMXvSvD3kVlRXg4RCWc5azNTp_jPeLjIUNXv7HrsjQmchZKU5ttGwU0dHhM_3ElvzOWMkaVRY3bPB_QP3dnues36_FjHtiB2G5OsyRgOi_5rA8XA0vrCVax3M0QUHz86JgARtk4ztPNN7PwV63QHr2gNj8Y_S8hbOEKGHLMMNSm9OCpnKSNIb_Yyn5dZRRg7X4o3HmGe6kp-vV0TiNjmFuSydU7baDtSLO5S=w748-h178-no" alt="" /></p>

<p>Phía trên là hình ảnh một kiến trúc CNN cơ bản dùng để nhận dạng vật thể trong ảnh. Mạng này lấy ý tưởng từ LeNet kết hợp với một vài cải tiến trong vài năm trở lại đây. Dễ thấy kết quả đầu ra (output) là khá tốt, khi xác suất nhận dạng được có một chiếc tàu (boat) trong ảnh là 0.94. Trong khi với 3 sự lựa chọn còn lại (dog, cat, bird) thì có xác suất khá nhỏ. Điều này đã mô tả đúng ảnh đầu vào (input).</p>

<p>Từ quan sát trên, ta định nghĩa một mạng CNN “kiểu mẫu” sẽ gồm có 4 thành phần:</p>
<ul>
  <li>Convolution</li>
  <li>Non linearity (ReLU)</li>
  <li>Pooling (Sub Sampling hay Down Sampling)</li>
  <li>Classification (Fully Connected Layer)</li>
</ul>

<p>Bây giờ chúng ta sẽ xem chi tiết cách mà CNN hoạt động.</p>

<h2 id="convolution">Convolution</h2>

<p>Convolution hay tích chập chính là tư tưởng chính tạo nên sự khác biệt của CNN so với mạng Neural Network truyền thống. Vậy, tích chập là gì? Theo <a href="https://en.wikipedia.org/wiki/Convolution">Wikipedia</a> tích chập của hàm $f$ và $g$ là một phép biến đổi tích phân đặc biệt, được viết là:</p>

<script type="math/tex; mode=display">(f*g)(t) = \int_{-\infty}^{\infty} f(r)g(t-r)dr</script>

<p>Dưới góc nhìn thống kê, thì tích chập chẳng qua là kì vọng (Expectation) của của biến ngẫu nhiên với hàm phân phối xác suất cho trước. Để dễ hiểu ta hãy lấy một ví dụ: Giả sử ta cần xác định vị trí của một thiết bị có định vị GPS (để đơn giản ta chỉ xác định kinh độ). Thực tế GPS không bao giờ hoạt động chính xác 100%, nghĩa là khi đứng yên thì tọa độ vẫn dao động. Do đó, ta cần một phương thức để ước lượng vị trí hiện tại từ thông tin của các tọa độ ghi nhận được. Ta định nghĩa một hàm $f(x)$ là tọa độ của thiết bị GPS ghi nhận được và hàm $g(t - x)$ mô tả trọng số của $f(x)$ tại thời điểm $t$, $g(t - x)$ càng lớn thì độ tin cậy của $f(x)$ tại $t$ càng lớn. Rõ ràng kết quả mong muốn của chúng ta sẽ là:</p>

<script type="math/tex; mode=display">E = \sum_{\forall x} f(x)g(t - x)</script>

<p>Nhưng nếu $f(x)$ là một hàm liên tục, ta sẽ có:</p>

<script type="math/tex; mode=display">E = \int_{-\infty}^{\infty} f(x)g(t-x)dx</script>

<p>Cho nên có thể thấy tích chập cho ta thấy được sự tương quan giữa hai hàm số hay nói cách khác khi hai hàm số càng giống nhau thì giá trị tích chập càng lớn.\</p>

<p align="center"> 
<img src="https://upload.wikimedia.org/wikipedia/commons/b/b9/Convolution_of_spiky_function_with_box2.gif" />
</p>

<p>Trở lại với convolution trong CNN, với dữ liệu đầu vào là hình ảnh, không giống như những gì chúng ta thấy khi nhìn vào một bức ảnh. Máy tính sẽ nhìn một bức ảnh như một ma trận các con số có giá trị từ 0 đến 255.</p>

<p align="center"> 
<img src="https://lh3.googleusercontent.com/CHzhgT6LqkFnIUgvBp4xf9p8j3joMV4K5LUg1Fw0RScaWnY_62fn6s6vt-U7lsUIw83YT958ija01-KI3oQsPjcnYhObpcrB7FAD9DGrBDFS-D8qk5C8B9JycXGuC5i6OsZPan_kmKV2_rUU2BNUZl0AkegPBtoNUjf-qPUd-b8AaBJTvuamJ9QUJ3gh8s2UEfVX881wsGtjsoCnICvGQR_xMYKFb4DZq0R7frS2Rz47oW_okII3IlgH0OM6KbO7egvvLPvNNKVWHpYiTwxGcRlcGjDso1rBtzkIsXWhmpn0l_-77GWa_EkPVeWb8355-em_p9VGN1Dbx2oGpEVY-kB3ktZIQAjIlIPbSyVytYQkjCfUak-P6VTU8Om9L1LdIPSebn6vxVHfoRK3zypTvmkjdGp4uSvgSWFq3a-p_6Wp9pDbDxhC-Lm0l4FXbDHBi3mNqmNMdcvjVrpL0kEj_MshEoGD2gxW8W0OZEjGByvO1xOkFG6jY5wQ6mP6H6yk6i545N40Z3K3AGPZUCHk1u8X4DJkvrlZ-h5F5UQFQqO7fYrVAOCfmTFgABt9L7Cjzqj9o9XduMQAwN3b1Pt2DRq5fSX2xrGBfIEIUGA-UFnlkskiwdT76VjMApTmFyYaUxpat4dykyx-qNttqrnL9SiVSbaSlslN=s192-no" />
</p>

<p>Channel là kênh màu của một bức ảnh, một bức ảnh tiêu chuẩn RGB có ba kênh mà đó là đỏ (red), lục (green) và lam (blue). Cách biểu diễn một bức ảnh RGB trên máy tính là một ma trận $H\times W\times D$ thay vì $H\times W$ như một bức ảnh grayscale (bức ảnh chỉ có 2 màu là đen và trắng).</p>

<p align="center">
  <img src="https://lh3.googleusercontent.com/_cfxkDvDsi3u7Fk1SuAu8R9og07kLn_LCggShg9HcHv-vxLwUFIFxi9BQ6km0vqdLXNalcRofE0Uay3GkI3wiAWC8aVCgo0x-qf9ZM_hgP3SNC1T58wC7xIV3dTql7lO3XxiZIJ8R2psxCvT_pAfFr3UpksSHaIY7kGgehCJnyq8ow5kBlFavPS7ES0yBrV-T97SupBRiPbBNTlcC4rAzfMCETRG1f7v27Sv51FKFLdVTbp7dzU7wn4UXlbkZDr2Ho9zuXQJ-4fYtv02ljFShKDDOJQXwh6PLjC3d90rwobLbrccGG8KDJuXJVEe-ZSGTsPV4LnWGz6nH2Lw9pk5iPDWiom02ERZUfNeH9CMbaaUz_WEWu_Sal5DDHvZDhTAT0HkvMLWLc6NXbWiO9EBsozT1G901zbnctF3m39-oARupTIdoeEtDCNy4tSo3-e_pu13VLHzgrn03W2yPZVXgp48Ib1vnmFDUMHkRqsmvGtL3vVSLKZb6ERv2qqqAOA9vAtppOhRWZ9cjysbVEqysyfK2G9i3Fle_3G_kL-yZjh118u_5MBKALQrjyfzlgCNQNYjqT7mwmJSB-44HE-ZIuVXKAc567QdiifTSuji0QchI6vUyMP9T8ZBKlAoBaM_eAUQXZ4Eij8QgbZKMqN1bWK-UpxloBr3=w231-h244-no" />
  </p>

<p>Ở Convolutional layer trong kiến trúc CNN, mục tiêu chính của nó là phát hiện đặc trưng từ một bức ảnh cho trước. Đặc trưng ở đây thể hiện mối quan hệ về không gian giữa các pixel trong một tấm ảnh, đó có thể là một đừng thẳng, đường cong, hay một đoạn gắp khúc. Để làm được điều đó ta định nghĩa một filter hay còn gọi là kernel có tác dụng như một sliding window trượt qua toàn bộ bức ảnh và tích chập với từng vùng nó đi qua.</p>

<p align="center">
  <img src="https://lh3.googleusercontent.com/eZTgfmBw6CgL_n7Zde39IXm4F9msW-gVjvAzPViRrIecG1rROvxXCyDnW3ZFHtmAr3ImfGnef0I3OUDLfZA0HMfeXpqVcPBDjVED4h7wqfvFjZwK-YC0rw7_lchu3FQU4ibXd6HIz5h502hM2Sif2jv6rQNlNiXPKDvqSF7wkraO4jfc-dp2NV_7RbJkn967b0PPzo0L-0EQiyogiGA58O-Kpy8kNxoM1lQ_RJL2TCCfogy-kAGNHW2zNojcb9BuQH5zwJEdd3uQAQ3vadoCmTsoAuCNg3321aUs_1_lcoMJM0NecSDGodp3IyjirixDXue9fk1AqwVY3nTuYxpJFfiM8o11-5bOZy7mJjR-xTxj2auc5kGYrncw7U6NmpFyz-nGzFaMJjivmS5dT8Dz8-hfZnJ86RQTmzMihk4v1wqILMXJ84G-Yn3oV_5ZoIDqFTSB6BX29a-xO1BFT4TAvly5kLzzos2wPl9QnjraGg46EVtbDZIxtZr_GrfErWeLMBhrVhk6Drb4H65Il3GI46FF_qFzytBwFUTiPYVxgC8KOVxREnNCtsRK2biWF0aP5pW2OUgA1NA17Wn783VoVmYkNKvPwtUc5ncP1VCx5B8vYuwBagjuDoHrWKnLMuHYRh9b72Kt8fawVaJZUxRWV8A2yD8OA41-=w461-h243-no" />
  </p>

<p>Chúng ta cùng xét một ví dụ:</p>

<p>Cho ma trận $5 \times 5$ biểu diễn một ảnh grayscale:</p>

<p align="center">
  <img src="https://ujwlkarn.files.wordpress.com/2016/07/screen-shot-2016-07-24-at-11-25-13-pm.png?w=127&amp;h=115" />
  </p>

<p>Và một filter kích thước $3 \times 3$ như bên dưới:</p>

<p align="center">
  <img src="https://ujwlkarn.files.wordpress.com/2016/07/screen-shot-2016-07-24-at-11-25-24-pm.png?w=74&amp;h=64" />
  </p>

<p>Sau đó cho filter trượt trên ảnh và tích chập:</p>

<p align="center">
  <img src="https://ujwlkarn.files.wordpress.com/2016/07/convolution_schematic.gif?w=268&amp;h=196" />
  </p>

<p>Kết quả nhận được là một ma trận $3 \times 3$ ở đầu ra. Ma trận này được gọi là Convolved Feature hay Feature Map. Phép tính tích chập trong trường hợp này là tổng element wise giữa hai ma trận cùng kích thước (tổng của tích các ô tương ứng). Vậy câu hỏi đặc ra là làm sao để filter có thế phát hiện được đặt trưng của một tấm ảnh (Feature detection)? Để giải thích điều này ta cũng hay hình dung filter là một tấm ảnh mô tả đặc trưng, ví dụ dưới đây là một filter mô tả đường cong:</p>

<p align="center">
  <img src="https://lh3.googleusercontent.com/0cTydRFzJkX7oqrytNbw9ERP3xyMzMkbeEt5JbRErX60ERD8-X_BAIUILaroyIp_GNFxa_0N_7FCIvz-XgdyVpZDpniWdCvuEn1Hxj92EMCCF5eCyhO95rBsKa0TGmTxDrGIIjPz-6J7pw8Mys3uxbo847DaMcXPw_ouwuVSv8_6QLp7mabeuK_bztGyFDHrTBmECV4S5W-o971AbKlvNrnuqYWjkzIJDuz3d1rx-IQjgDr_yH_M9f_GIZbMf2xP5i-zRNGzVuojyMctEcD5YzFevXqHdAuEkQfjBRUc_xGBaWUKSBAbv5Ir8vfK5EK15VoIOo1_5FjJUOeLwsHaimgwjMt36JXtgWaX98XNiSuqFrJLTzpK45zBnJy8ah4UPdJjrGW0u84ikRfmIo4fEAaLJjt23g3yGOUXGJD1vEBM7bDFXu5-5Mo08icpvxMpr57_h7XBfdNbkxf6N2_CxJL4NxCjxWDcHiyDbPj8QERqf6BqKnvWuE4OFiik5oSLI4lbGjtFUEQdysX-WDZDR6kbgw294ykEh8LCf05uOvs3KbYE4Arb0FIxnaUF9Fiw7rNQpHvUEcKQ0na89KOohBvUUzlJaVKqL7KygL_b6Dj9wokakHOKQqEoPrg7W7UiDKGFdbl-QnYfMlaerEteBhFt84V4AQlu=w624-h278-no" />
  </p>

<p>Ta cho filter này tích chập với phần góc trái, trên (ô vuông màu vàng) của ảnh gốc.</p>

<p align="center">
  <img src="https://lh3.googleusercontent.com/ee65AFu7qqPJTr7ie0Z2-IQFSIawdEDFXGiVESsjCBsItIqdARbIKNig8Mhjx7nPVgZ2UsE5xaY60PpTzVs9Qywd3Ale32lovJqyXlaOZz0mfpaOO8kESlpB-IJMm0IgURugoc7VUpF7wFxhlYTf4OUyrTU-29_0AY6srrma93em2i2JaYzJ4aAhWOUfubKk81zPGWHamZJsoOmXqGVyi7MW3IyIe45qen82PRHpHdNh_lBbTWWzwpJ0uUzH1fUIEAYdXgZZ2q3_68wkBgZjdyCLx5JaOjLlTcVtMk5DF29_o8orZmgUVydMIsWk9gJJUmsln1us1zDPTjHkS_yXx0l3sxX3T_alniAI93jlmcxzVmbl9AHEZTqS4OGhg0ucgsqTLC9jaDMP_h6XGjTvBvuYdGgE3GAdzDnrHLZO3Ew22itqw1o_T2vJJ4rC76u6tFpagSZIcGYrl8DmiygFrbHlfux2g-FSsqFyJEnvqCkrLcGjqxypnqx_AHaTdH7AttlBAenNcFDabxQvURmTpskwa_0O1ZoYe-BXl59vbJe_ZeULBwBw1j_h-8nqLMMJxWukbO1lXlBc1ARYqx3OogH-2e481BCdH-WlS-35Rtw-HsgWbTDl5AqMrd0PjNxL32c4lf6yEBGDo8cAbQUb8c0XH2fLk9ga=w645-h229-no" />
  </p>
<p align="center">
  <img src="https://lh3.googleusercontent.com/Y7Xoeoc67R4wbPAiMTNukbEztTt-Oitay8eYGehVNO-jvEj31mAl1F0HQSheDsuXckHmTQ7CFl4QpLhyj32ZEQvKkf2xVSC1n6uXtPteoJwo1EwgbCn-nQRB9HCpTj2Y54DH1Cv0aiK0ix9B1K1_1jONXaJSeEalUzgWgZ5LGqZh76-_CIsmt3Y-IN1Q19Fe-cpK4JK13Tq5_FUDPxy7xzCY1eS5LC7_VYKRrkTmQPbEue5g_ueRWC-gRa_cPPpYq-Mq0XPZamwSkRNSPFdnEKrokNj3r4aOSwhlwopEC66927NtS1UFXyVPR0JKmYzriGiaVLO1zojvfPAe2Pg8852B3GpOcblNTqSvwOjes59Grq37BgcUjnC3Zimu1nlZ7g5CDtyDvOso_1zUsnshX3xHH6B3P2n3EZQFBDHGZuGCaj0xQOv3eNLIMJtPNuj7BGZ-EV99WGPKZfFqWRbMb_zB9W97caH8X4NYe40vTMmlELMmNGWJElMlgZnFqYDgOvxJnslg2vYoOQzmaXfqxIsOIQzSQAz5p94JKLGlzr-isy5pjU0C7HdIL-OleigyrCVPmfd6KMcy99kTi46jkpqsMgYUfGaLsSQGAqfeet8d6aVJl7fnLg4kB6a8K8c_hdlc-D8eMpVwOleUt0B9f9l-CuKu8tOp=w711-h268-no" />
  </p>

<p>Kết quả phép tính tích chập là $6600$. Bây giờ ta sẽ thử filter lên một vùng khác của tấm ảnh gốc:</p>

<p align="center">
  <img src="https://lh3.googleusercontent.com/fXxIlkanhcV2yrdG4_73O9q8T5tbM8eiApRtS2VpR333rcLqykVrO7Hg2NaOBNO5sw5_DWDJhbZIaFFLlRAunDitFoVWsYC6UZ2gbn5Pa1TdSPU1Aw7OS1DI6Csrjr91TcX882inSXwb0WL5tspjCkVqFa4HqlX8MgzbSzgxumhQZjv1ezQSmEKlbF0KxlrSlwAkpaL3rmEam_Q3_PN8e4T20Z0fpJ4ZAGO-OT0qIWu8ceem0sLyJoTQFFcNae7ySQHQ2366eUu9YnzX1IZAB5mi4P2WLz3p8jgts9PgisRXP1vWYtKQ9sKQRm6mmDoZ5V-O3_6f9pDE-EN9JryP-LIszgt3Y20Wdtse02n9UQ36SmLOE59Bq-qMs7HmHaI5yrIM8hlxYk2xMDWtqTm1LmmGKv-8LqoUYEI_EBqO3XwgPpnAK06nPNcZ99qBZryj6iKo07-5aN1KUcj7Zb6gd-uPv7d6vAlHB33AlmYJTnFMh8zRpXGSXmQIya0momC1soT_8LVIKgDCeYtqWnwh-4CMoh4bQWkDxwhdFdwOttTHwqTcv7HFzmixbFHydUhh1e8CkYPqCf5gNLqRSoiYbOlGmHisngq0DqZJGSS8pTYN4KdV97SQeZn2FreH6KcVlSr5uDGFeIG1gsBALLTrJhCPE7c3Npuy=w718-h251-no" />
  </p>

<p>Kết quả ở vùng này là $0$. Do đó ta kết luận rằng vùng góc trái, trên của tấm ảnh khớp hơn với filter hay nói cách khác là xác suất có một đường cong như trong filter ở vùng này là rất cao. Tương tự như vậy, ta có thể dùng nhiều filter khác để phát hiện nhiều đặc trưng khác của tấm ảnh để có một cái nhìn tổng quát về nội dung bức ảnh. Ta có một vài ví dụ về các filter phổ biến hiên nay:</p>

<p align="center">
  <img src="https://lh3.googleusercontent.com/z-6rHekkm-BrwvkPof9B80-4Gt-UM4v5L0mBIhQYOKDf1EaRBZLmaWTf29Do7UBHhnPjOjTWLUy3fbVXW3e1ky8c_lMe--vgkq291GEQgFQEH111eSdkJwWMSSGPc2r3Y3O7jZesoC-Np04QdTzCDshXLPShnCk5DFftk7DsA_Ts33l3F9nt5LjXqHm9gmerY5wIkOq2zO8gZU_SmwH__7cLqWUeT00DRCERE53QfsqXvBNQvpNaUjRqmPiqG4E5nQUd0i_Zm9pB8HOe-SvzQ1m3C6pgH8tty01AAMqMwpt94BzSMl0f1LHqbjI5WMPsGko_tOrhShpOfavTXiB_LbsH_JugA87uxQxsEkfyplcRkg36-S4SOfq7jH6IRIhG8-v5W7fJ8dq3cs0K1jDgT8EbjE353XN93W2k_rVg3NqBn4GOOMOU-sK3NitoGiqyLnzh4hOc68GkcBIiOdJYNMLmowv9Ftk-MCikfO_LwwNKUATXWZdqMEICqdmoL7F31zDUHUwEabv3drZ9FW69kZ8qrGJrPX_4r2ftYupRWL-WcHuHTRVDA2rJSFfbmNgv4vnwq3U-yTGTTzNNijL9NZ9jX1gapiiscnKcUdjsupXCwXyO7RWUL2HC3fK-nrb-oJknb2Ru6g0ndtzS1MrQXtm5gA4UqXiy=w67-h66-no" />
  </p>
<p align="center">
  <img src="https://lh3.googleusercontent.com/uKPMzKui-9AT1563MMmbGqSTWEbL86OMMiX7Kq5WQ7uTNUTpOme3TykzBYYGex3DJavqaF3OkJ22x1EzFu6d3aTV5pUYqLBguU6Zi3QFLSvfVD1A925G0_HVIlgQb1Vn-jhg62uePbrDVHqegleb5M5PPNB-XYFBB-q-WfI2qoRgtcjfaullXu2OXh6XkLhguVO_WZxltc4lVA8ITAhvIYZOo4n29PHvLXWk0m5WVDJBJKA0sBZ6yw9Z8O4CxHllB3JA6wyczkHLKBaQwL7W7wT0xDzmDt3PRsXY5gUeXma-QyuNWDTZTmBwJXYwtQ240wERO2Fp8FjZksUxubw5v2EgNFntoo_lJ2rTfaoqeqD8uCQFUOlMPI5dNGkPjGsHdoc0qtJ7M5036raiQRgO-Of5RSIlisSRutgQNWzmssCBHb_JgBYImeNpD0IUFF0D9NnQ3RElsk6rCfFGNb5eJRrVtfNVdfDOqXI740sZY-iV9wNtRvCuieGPPTaw_mHqXtPah9Rhr25GoHdFujwiR_goa2PResLv4QBIedkX59ywSCrGVWdVezEJOrFRxv_K7SEIDhxbfon52vY8e8d3XW_KK8wCqzV0T28hHuWT9AA7zruWqGZA37OZZutU65WUlzw4XL0t1034XbAFqYqkPWG6el84OaJ_=w342-h562-no" />
	</p>
<p align="center">
  <img src="https://lh3.googleusercontent.com/Yv1UcvPApQZSZJH01jkLduxFgKwCFEFyzUiRziP651QWPyk6HUt99jg2htGqaLBHXuqKLtpB10MWQhXdcpF_ncYAj3RlOtkzqr_k6JCTZ7yxHCO4IP0K88dNoSv1GAgWviuT2QuMOQ98Kyewa7uvCsjHykRtpjFQFEQRlqr20J8bcIZAgS9PkMfeQXtrXcLorVUpujQGbxjzrm1hX55wlY4T3m2utiuL2k-07l1AdQGGmiDQXqllFGPOWDvUZx_GDzzR9sKF6AG33ViMS7DUVaHShQizHvqMcIrOaRP31P5sucIKHfgdqMswYF6Hmc7_DvLUlneQt1dsjiPEHMXsoGgOwe0R8MmFfV6chICeqWOygEdJJ8oJdaNsapNSh_xLUOC0jLF_Yc1eCCwBDaEBpRUPTXWy9StPe0xwEV8uPqOJxShh31lhnwdfzFft-_AdDq6Wm26uUNLhVEdVYJvsiYQtAvaxZzM8h08duqOo8SSYD6jufopZRI7yhZRafETBS5jNym0xeDWGeqZrKtJcDwge139PTSxR4k3jRaIMl5TrqRTHr3p4rpx32Eiq5gUdPD5j5btczpfrFJT9pRDrMQSIPTxpW0SNAB4R9vA2kPRORtiyTy5Uix6toAAnWsAG3s4LIdjq4gnH3By859xUmgjQRp6BI7wt=w480-h272-no" />
  </p>

<p>Trong thực tế, filter chính là cái chúng ta cần learning. Learning các giá trị của filter sao cho phù hợp với bài toán là mục tiêu của quá trình training CNN. Tuy nhiên vẫn có một số tham số chúng ta cần gán một cách thủ công đó là số lượng filter, kích thước filter, số lượng layer,… Càng nhiều filter thì hình dung về bức ảnh sẽ càng chi tiết và xác suất chính xác sẽ càng cao.</p>

<h2 id="kích-thước-của-feature-map">Kích thước của Feature Map</h2>

<p>Feature Map hay Convolve Feature phụ thuộc vào 3 yếu tố sau:</p>
<ul>
  <li><strong>Depth</strong>: Độ sâu hay số lượng channel của bức ảnh là yếu tố đầu tiên. Độ sâu của Feature Map nhất thiết phải bằng với số channel. Vì thực chất một bức ảnh RGB sẽ được biểu diễn trên máy tính bằng cách ghép 3 ma trận pixel lại với nhau như đã đề cập ở trên. Vì vậy cho nên cần phải có 3 filter khác nhau cho từng channel.</li>
  <li><strong>Stride</strong>: Lẽ dĩ nhiên kích thước bước nhảy ảnh hưởng trực tiếp đến kích thước của Feature Map, cụ thể là chiều dài và chiều rộng.</li>
  <li><strong>Padding</strong>: Padding hay Zero-padding liên quan đến vấn đề weight-sharing trong CNN. Ta thấy khi cho filter trượt trên ảnh gốc thì những pixel nằm càng gần tâm của ảnh thì sẽ càng được filter chạy qua nhiều lần còn những pixel ở càng xa (gần biên) thì càng ít được chạy qua. Do đó sẽ xảy ra trường hợp một số thông tin ở giữa tấm ảnh trở nên được “coi trọng” hơn (vì được tính nhiều hơn) là những thông tin bên ngoài. Điều đó thường dẫn đến việc bỏ qua nhiều thông tin quan trọng, vì những thông tin quan trọng không hẳn là luôn luôn nằm ở giữa bức ảnh. Để xử lí điều này, người ta thêm viền ngoài của bức ảnh những thông tin giả là những pixel gồm toàn số $0$ để cho các pixel ngoài biên lùi sâu vào trong hơn và đóng góp bình đẳng trong quá trình tính toán.</li>
</ul>

<p>Đến đây, ta xây dựng được một công thức để tính kích thướng của một Feature Map bất kì:</p>

<script type="math/tex; mode=display">(O_{h}, O_{w}) = (\frac{I_{h} - F_{h} + 2P_{h}}{s} + 1, \frac{I_{w} - F_{w} + 2P_{w}}{s} + 1)</script>

<p>Trong đó:</p>
<ul>
  <li>$O$ là kích thước Feature Map (high, width).</li>
  <li>$I$ là kích thước ảnh input (high, width).</li>
  <li>$F$ là kích thước filter (high, width).</li>
  <li>$P$ là kích thước padding (high, width).</li>
  <li>$S$ là kích thước của bước nhảy.</li>
</ul>

<h2 id="non-linearity-relu">Non linearity (ReLU)</h2>

<p>Non linearity hay khử tuyến tính là một vấn đề cần thiết đối với CNN. Đây là một activation layer đi theo sau Convolution layer để lọc các giá trị trong feature map. Có rất nhiều hàm activation có tác dụng làm khử tuyến tính như là sigmoid hay tanh. Tuy nhiên, hàm ReLU (Rectified Linear Unit) được dùng phổ biến nhất đối với CNN vì nó giúp train model nhanh hơn những hàm còn lại và tránh được trường hợp (<a href="https://www.quora.com/What-is-the-vanishing-gradient-problem">Vanishing Gradient Problem</a>). Hàm ReLU sẽ fix tất cả những giá trị âm ở Feature Map thành $0$ do nó có dạng $f(x) = max(0, x)$.</p>

<p align="center">
  <img src="https://lh3.googleusercontent.com/cmuAAP3f2DUnJjQ1XfDjHAssi202FZoBbHoFAFb-aXqckzw8xCtreJ3G---6IssGJuXZAUQhyN_Jmrn7i6IMb6KdXnB2oGgLqPEU1UhGyIBvzerEPyNcG5c5gOga2nw3LfyfL6Xf4F05guMawjb0rBG-p2i3xytSczMh0MEo4F1PGE1aGldiRaj9z-vgrE4tI86ZykUVWl2dt3yDdE6ZBNH7uPHOlNULp-4gOAdpCrXNx40ZR9hTCmg97Iy4XPB7voxrH6N3VbOEnjOr-GWyGc2tWmgKUX30ujK67U0H4pmbNRv5nZfR6w2-WnyX7F99xoQDEWOYNljvJYg7j6UnsmuBhAlQO_DuI3raTqMPk6jHYFkzRN3peCbJDtnZCjwwTTwfNJNOSGLA-GHJwCvBpFfY570DEGkwzk17AO2bIOKz_vNyBwfomAPU-kyqjExncCAo4P01sEKiBARWL4YhMTiVy3BHGUcf5AZ84thjaXALz_o2S3TDHhtpNZbzXgf4ZXDr21ORjJghMG5m1wtk65BSj5jmyDBcARzdpW19BidXsFpQogV4dQKzF6sXYzN4E0fRmdZrzyIe-8C5gl6Ls2nHVYMQNekzwSJ64kehatRIeCShTZbrZMf2yxX3MvbtL8PmQLay92RzN6WFptT6eacsrWC1n1E4=w537-h168-no" />
  </p>

<p align="center">
  <img src="https://lh3.googleusercontent.com/j4nV4lt91aErnwyM4YRbZPd0j8Dy1lIaVkSotfl84AONvj4Qiw9JN79G4bFELwOI1998LV81Ss7NQKQYUedQzFRJDsMs5EpM-pGpCRdmQ4GTmOINQy9uuxkgtSU3DXJJRTA59VKeP0__CuOrbJL8GtU8G6FtinT20swkf_fAP_YHwovDyOrEvCyOcxTQsfymR8EDDaPUUhA-FiwVSUZ-Nn4i6UUyQ4Pu8mO-DVTfogt7hwc6JVSoxImAZ2_nAQ0ZwwHYMn-xzCsc3TQzPCuen4xOL5ka5FRSndzq51IgGyEjLWnvSb8hffKQ18Ghv5tSB9MRa-CVhJApsFL43n43P2PuvJzAJ9zkhrcFRo8xEkVqWFAHr2Pn1Dn5V_X_j4RppQN-Mk98OW_eFfrjjayQXfWzIN3jAMXreZ033_QQG5KOQbRJWjruuTR50NbWtPQYsoW-xTV4ZtCbxdAw0t3P9seyWwnqK1yLEgmp7It1tukBp-a7pcN2C1GnS6ZONkIvAwmjnlDfohZEx_dHZNm6QIqjIS-ZAlbIiwxfRUR1R8EYEE7WNKRgPkAWD5qMq1b3e117SFkaA8RT7okEC-l7l_PCTevMP-DHXNg_GHiQ8DO9cXn8mFt_DaV5F95y4YjToYSzGcRLtPsFLf5rurRZYHvYbVpPWm2Y=w449-h212-no" />
  </p>

<p align="center">
  <img src="https://lh3.googleusercontent.com/gc-QoUtqCQOfuFGI7srrw7IZOGhQPhXcpLwUg_OBBqMRe6d_9Ij8_b5BResXDKaTYfCQKMAKU35dhK_o05tKvKPyCu2qL3dQYrIuBNNuiTd8DRSAfX_BjG_V9EGzzdo5ylUMFr8O-5vWwBoMRkVbfbAs4BvQlyDce_juwa3CX16nnwBB1apyDiFlXZYB_conAl8w8LOUrpp5CwwljuVMONARQBbCTL2SxIUdbtE8zMJcbObm4L8pBNDIVy1Ya24-GB7dAddIKAwdP4kIGq0OTFtcGQFi-VgUB8vhHRunXRNZ_L25IJSqHHoBX1dl4TOU2ifZNto4MkagvzlCoa75rAFJ79xh5Hm5x-wHNGFrZ86fUduobMmFyfztqMfwFALRxGVauANAy7GGyHnyBo4n4Ycz-XWb6-i-IOstEqVJGYBS5ZyPTi_XWrEn3kJIVC7HM-lraeRu91lUG3AEsJoyUnb7X-ZKPX7CISvNglEIIhAFGr70xbAGyH4Hj9w8pIGZbFXyLIkBZP4rTCqFkM9MRORxECSyaLRT_jjt-yMBv6_0-pK5tjAuTWvUR8LpjITo_aRjs9ODekd65tVtnBsY9AQVqeCYH9dQNs6sxXGoxJWsm5oM0SAS_BuGB_RotrXEKSBBzoFDrGSuzisnLTA_u80NSFboeejJ=w748-h280-no" />
  </p>

<h2 id="pooling-layer">Pooling layer</h2>

<p>Ngay sau ReLU layer sẽ là pooling layer hay còn gọi là subsamling hay downsampling layer. Mục tiêu của bước này là làm giảm kích thước của tấm ảnh và chỉ giữ lại những thông tin quan trọng giúp kiểm soát overfitting. Những cách cài đặt pooling layer phổ biến là max pooling, sum pooling và avg pooling.
Ví dụ, với max pooling layer dưới đây, ta chia Rectified Feature Map thành những ma trân $2 \times 2$ và chỉ giữa lại những giá trị lớn nhất trong đó:</p>

<p align="center">
  <img src="https://lh3.googleusercontent.com/d6ey6RbxaVS5VJlXrC54t8NzYkXUbSPu_rwJeacDGIAdA59PAoFBiTugBH5RV6X9oxTlL7IA6BushLlcaNngVPzhSCvXkZqT5qkGBzWd4VU4FO8Q7GZQ-yGXQZf2WMWNJr1H88Dq_8n5Mmf3eWB9yL_UdXGbYUUwh_fmGOA-AKahuUE-CqKd-57eaMnVtbbqMftf1l55CIOHFYKD1s6VVg2QOep9Pu6F4KksZnAGz6i2PTvKo3FThKu5p4KJIREXNevfPs0EYDT-hE2hGtrwdIpQjrAGZ2hsNvK3kX-envdycctL9bYuL2BojIT0_x77G-ChFCcA7gsAtxg5PLo_XZENWco2hzoDKvpOn7xxF9IC5GgFgPPQmoTeNLd7SEAGltThPNBfzFDHj_VVJ5NmRHp8uEiicIcKyOKhrmYYMDHAaPYxBYaFoJr52c4qzAkUCB0vOtLZSyILdwnAMSTFV0KaXrLznrIINTpag9CIMixNPSPxpqJK1_uUpaIc9YpFE9gCah_OUSRe6t0JBm7N9EmzSPUNYUrJgFxp-4jftU1aevJrWPnZQa9vQJDQF-lkaPSyTaUuWB9EjrAyoKegXACu55yR5u8sHHXPDvH0AfP2mqhAo1B3KA-_S-kPbm_uWSZSS3X2R8RS-gr-OUYPYEL3jVEx9W5b=w494-h421-no" />
  </p>

<p align="center">
  <img src="https://lh3.googleusercontent.com/RPNT2WHZAcZDsmpis7BzHmhOA5E1XGBgtCs3hXqJUrHhRJmjwPsE9DhulKU9rn8ZfbICGK0LFfOiDJSp4CnPN60GqOFKxmmzlZEVE75ZLAc9FqmfTbGxvGXMevLctLfXYPCefyuhRZdhLANvjSzb7KzfKfb-i3pDJMbI7ZKlgQfwOo31V2hmZ-5L7_M3pJFaHQgwDnEWbHMgAhtZEZ5kHkKXBZDwMz6MJEJNAaWRhWgOdcQzofyYcJvFSwDyM83a9uQ6OIlKy6ti4mD2xafrKv03FoHcCkeldolWZeek827Kq_JCUx9cvj2bfA8OxCocai0ep415aCDRTF5b1oyvWOUpNnkQkMFiCMbK9zeWnj5fBXxXskSs9Cn037p0tXxFmrzCfn8b9mFnicK18bnRzby_M_fGLv0uSZOxxwjJVH2y7pK4_wQzlRBNJNiYqdoBPifagKaXTv45zVMkzJeg72_Eq8LfNt8BAmHn-wBVoVwDQiZTztxIX32kXUG-uML-6H0nbJperWRenJyMkanetX9z9onUUrAevHnRM1xVog54C7q0VvnD3Ny7JjWrr4JRbdUzpa_5HTOtTgqI5vRgviJ45oyWeHoc0QOHoOzYd1x7mlLC9pFczgufhyvWLStGMZiupDGEhg87UxwDFBgvf3rmB1lscG_1=w748-h319-no" />
  </p>

<h2 id="convolutional-block">Convolutional block</h2>

<p>Tất cả những layer đã trình bày ở trên Convolution, ReLU, Pooling thường sẽ được kết hợp với nhau để tạo thành một Convolutional block. Tùy theo yêu cầu của bài toán, tài nguyên tính toán mà sẽ có nhiều kiến trúc CNN khác nhau gồm một hay nhiều Convolutional block.</p>

<p align="center">
  <img src="https://lh3.googleusercontent.com/DgeoBnnyrGfwqdB8Q3YfCFTkia9PNIf1NHpM75wWtjkP8h_uzv5Kv2WCSi0IHUaNHQtfm2332JDdCRMvwOr-7P0Ubi6yGpq1nci9a3SFX2kdAZ6OfE6IziZQ4Otji0UNlZMTMGHq_9H1q8Yc-IA77igKdQfidU6dP2-3XiTBSAY0ymAGU-v0Pc3kq54J07QnFRASTSZPs2Sedh2dCRzRnfptD2TsaHyyF4plrfnBq8FjbVhyvgWgNftq0KBXGND0wk_hTP8AZdee2kuoJ2ros7l7Y5Ad7qcdLwR9iQuKZiQ2BYZSRr-dSG5JSE54qSbsniZH_XtBj07Fv3F3u64rvjHmYlezKCG_e18WL-l-7HLsBGs7ElN4hmcfzxdLyaNztbAbLWD9jmMXzXNRUQmGOwHTAcInXdjysmvjh3HgqmT5mEm4Qg1XE1xreZryKSaeUNww1wNs6mDtWFfVQL4Zy3QL0x2tfwieH6B0TvhESAg8yHZgMzqlKli8UA74pz-D9zQHfmC2KnZAxBR4qfX3x0vFV1EwhHq8kivUgD75vWScarkHZIbhCgwpPCwmNkAaXDHcwZ9uzaiwSTUwKH5AQKjx-dxVoN2vl_OUKeHp0ndMB6k6wZyfSsiOYHNzXpsGUiOctv0Bpuq133kVGX2rS1PhAMXGsea4=w401-h219-no" />
  </p>

<h2 id="fully-connected-layer">Fully Connected Layer</h2>

<p>Sau bước convolution, ta đã có được một output gồm các feature đã trích ra được từ ảnh gốc. Công việc còn lại đó là dùng những đặc trưng đó để phân loại và đưa ra kết quả.</p>

<p align="center">
  <img src="https://lh3.googleusercontent.com/wJTm0LRTJmZQMccGS5Vr-jjcWvW_K9q7-Bmy6oAzWS7hI-XPgn3Y11q-msf_DwEMdiNvUEsxfMsiVk3YHNqFuAUnG-QwQ8hZxaTD1vUAZf0Fb5aAElyAvzlZk9LE4AgK3hEfd85eyaZIlSfcy1Y2RBv8MVJwG2CEV_408jmgTMveOyTZzKMoGn1wWNQu_Y-9YT4JYOQ-C6-S09Qh9eHX2u84LUulR9iXCpKQLsJ5hX7Oq69uSDP0DmzIEj1jJECeLczxXdf142nHACGLXZCl_QUgNIb6SyghkkLZmwPEBtzAPDRl2V_IEOh9jof959njq-TKXMzku6m0PMEo3fWh56RNS5GmxPBlM8UEBvteYtwr6VLvAiy-l5MxhWls-EyrEpiphrrbc1tK1Z73DbDcA8oSfSb6_qr8LfgZOEadKrcflJCeY92JPdpfGRZDKSRef2jl_C7AXILyiu-0lBz6EeDdF51YApT2wh4kh8D4Apjy8utmHzdSBZOKZEaStqS0QNq1XKLSlubTolDNEXAxDVRz0TGZEQnVQnH9UGFkYzkXircXKZ98NxmFj2m_Oa69kYHfDxFQl7NAGDlPm9NV2kBFKfunX8FVF71VQUblvPdPnKUHNbKdvJcNyhBynh32qMN1e1UPj6GZHh64_ULvluMEdLsMrN4R=w748-h263-no" />
  </p>

<p>Để làm được như vậy, ta flatten data và sử dụng lại mạng Neural Network truyền thống với input là các feature có được từ Convolution layer và output là một softmax layer.</p>

<p align="center">
  <img src="https://lh3.googleusercontent.com/kdXwAI6DAgaZkP1I_KAEIosdAluHKUlIhs9ZrhnQ08kE6dfNyGUBwW2r4vTt3S9KiO2CnLvt7ayfTVthYO7BQRS_wlzT2QmKtRJ8d7YzVZkafcF6-XD06W95QJxqYyVVmdbhrKw2mP4LxH3Gr7bk0BmuCpH_YJkyrcxYc892ffEfUiC8EIbmSXTt2nlmmueS6bxPi0zFodM0N7IbdQ-PGvZCJdavKWJXJri0_fBuUm0rAGkBNPHFBBMGrZbnmm3G9wfycrAAR5icSuDfmA2wLS1mBO-QYv03qCYDiYg-VdBGG2hF-mZHinavshr7y_bf7A5ABL4eLE8EzW-3Q5kD4mmW-M4v4yKu-Z97RDEJWI-yIza8PJ6wtUFPhs0FE3rqPGWzdjcuWKXBziwxxZdmpqg3PTPmSRjdqbfxEs42UNbm5Tdl_4o8q0Vj-UKH1YxkCisEM3oo55BxJwUThKY0bia4n3TiR4cAQp9eUHXNH1W5t6CJpu8M72H0zEsoPZU0rmkVNhnjKVIb40PLRj0YNnihuxPqKRCktMMXSNSJXxKno27Hx7jWgHfmusbCXi1YFPx0yq2Ky3aVeY4dVp1iRwGV11lkwlAn_4V2rwFIycf0Roa6gYU3nkY8mFEvEoi06zYNr_fv_zsNQiElvm8ba_ZU9INDljan=w554-h300-no" />
  </p>

<p align="center">
  <img src="https://lh3.googleusercontent.com/a0-mOaZInMgpJSZsL8_WBQ_WjvEAKm4ecuywYPI6Q3hkn0dV4vH4mYdXO85_a0NBb773i1lC3mR95GHVdy-jswHK6Sl5sCQOt6E55577Mdor9xp64YGQKNt-phnInMMPm-VZFxguA9tP11rGWgtT0ZipUCifAyAbJa8YS0O2cPOurcD0foz4X-gi8rDK39dKdYY_FoZexM3CGJ4e8bl0Y6fUdqV5Qx8e0XL0kCjROaXCo4Ml4zF1Gnnd6nVTxIu_uxdn8w6FmT0ZdKYZINXPldOxujgVwrC_yH91P0hGJMJ-FHSuZMVZexIQkdZmloHTKGG4Bi59G3HTpvS4QFhH3eHagSuahxVjjdeeBY1z5-22lLNvSbE6gapP5F7xFkOKdad68ODK5BuW2t2fn8qu40pOaUr6t17qL40NBtTlehBTJD6eQeMLMPr0DNUX_wktwkyWlqszCD-6i35dK3Pr6vDOXjipR01Mw3me2nwfdqVB-EMclAku2HZma5b0xEThH87kwZeqhIFbuxi0Shh2YOJZtE-oisKv3YAYX6WDvadYfg6Dl40Hq8ARy770hveb9Lq2UTdmQZkblX69Anww8J_2WupZIshw7nQpasJDDN-RotZv7YvHh9QJUXngNsmbGAk5y4sFdjqvV_m5uViqXRykc1vDZ1Jz=w484-h152-no" />
  </p>

<h2 id="training">Training</h2>

<p>Sau khi đã tìm hiểu về kiến trúc của Convolutional Neural Network. Chúng ta sẽ đến bước training, cũng như nhiều mạng Neural Network khác ở đây ta cũng dùng Backpropagation để training. Tiến trình training có thể thực hiện như sau:</p>
<ul>
  <li>B1: Khơi tạo tất cả các tham số một cách ngẫu nhiên.</li>
  <li>B2: Nhận ảnh đầu vào thực hiện feed-forward (lan truyền tiến) và tính đầu ra cho softmax-layer. Do các tham số được khởi tạo ngẫu nhiên cho nên xác suất nhận được ở softmax-layer cũng là ngẫu nhiên.</li>
  <li>B3: Tính hàm mất mát (loss function):
<script type="math/tex">Total Error = \sum \frac{1}{2} (target probability - output probability)</script></li>
  <li>B4: Dùng backpropagation để tính gradient và update các tham số.</li>
  <li>B5: Lập lại B2 -&gt; B4 với tất cả các training set.</li>
</ul>

<h2 id="ví-dụ-với-keras-và-fashion-mnist">Ví dụ với Keras và Fashion-MNIST</h2>

<h3 id="fashion-mnist">Fashion-MNIST</h3>
<p>Có lẽ bộ dữ liệu chữ số viết tay MNIST đã quá đổi quen thuộc với chúng ta, đến nỗi nhàm chán. Có nhiều người cho rằng MNIST đã trở nên quá dễ khi có nhiều model đạt độ chính xác gần 99%. Khiến cho việc đánh giá giữa các model trở nên khó khăn khi dùng MNIST. Gần đây cũng đã có một version mới của MNIST đó là <a href="https://www.nist.gov/itl/iad/image-group/emnist-dataset">EMNIST</a>. Trong khi đó, <a href="https://research.zalando.com/">Zalando Research Team</a> cũng đã public <a href="https://github.com/zalandoresearch/fashion-mnist">Fashion-MNIST</a>. Fashion-MNIST gồm 60000 training images và 10000 training images thuộc 10 classes khác nhau: T-shirt/top, trouser, pullover, dress, coat, sandal, shirt, sneaker, bag, ankle boot. Chúng ta hãy thử cài đặt CNN với keras và Fashion-MNIST.</p>

<p>Đầu tiên là import các thư viện cần thiết và thiết đặt các thông số training cơ bản:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">keras</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">keras.datasets</span> <span class="kn">import</span> <span class="n">fashion_mnist</span>
<span class="kn">from</span> <span class="nn">keras.layers</span> <span class="kn">import</span> <span class="n">Dense</span><span class="p">,</span> <span class="n">Flatten</span>
<span class="kn">from</span> <span class="nn">keras.layers</span> <span class="kn">import</span> <span class="n">Conv2D</span><span class="p">,</span> <span class="n">MaxPooling2D</span>
<span class="kn">from</span> <span class="nn">keras.models</span> <span class="kn">import</span> <span class="n">Sequential</span>
<span class="kn">import</span> <span class="nn">matplotlib.pylab</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">batch_size</span> <span class="o">=</span> <span class="mi">128</span>
<span class="n">num_classes</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">epochs</span> <span class="o">=</span> <span class="mi">10</span>
</code></pre></div></div>
<p>Chuẩn bị dữ liệu: Tất cả các hình ảnh từ Fashion-MNIST đều là các ảnh grayscale có kích thước $28 \times 28$. Fashion-MNIST có thể download trực tiếp từ Keras.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">## input image dimensions</span>
<span class="n">img_x</span><span class="p">,</span> <span class="n">img_y</span> <span class="o">=</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span>

<span class="c">## load Fashion-MNIST data set directly</span>
<span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">),</span> <span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span> <span class="o">=</span> <span class="n">fashion_mnist</span><span class="o">.</span><span class="n">load_data</span><span class="p">()</span>

<span class="c">## reshape the data into a 4D tensor (sample_number, x_img, y_img, num_channels)</span>
<span class="c">## there is only 1 channel in Fashion-MNIST</span>
<span class="n">x_train</span> <span class="o">=</span> <span class="n">x_train</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">img_x</span><span class="p">,</span> <span class="n">img_y</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x_test</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">img_x</span><span class="p">,</span> <span class="n">img_y</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">input_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">img_x</span><span class="p">,</span> <span class="n">img_y</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>Normalize ma trận pixel về kiểu các số <code class="highlighter-rouge">float32</code> từ 0 đến 255. Và in ra thông tin của dataset:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">## normalize data</span>
<span class="n">x_train</span> <span class="o">=</span> <span class="n">x_train</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">'float32'</span><span class="p">)</span>
<span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">'float32'</span><span class="p">)</span>
<span class="n">x_train</span> <span class="o">/=</span> <span class="mi">255</span>
<span class="n">x_test</span> <span class="o">/=</span> <span class="mi">255</span>

<span class="c"># convert class vectors to binary class matrices</span>
<span class="n">y_train</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">to_categorical</span><span class="p">(</span><span class="n">y_train</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">)</span>
<span class="n">y_test</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">to_categorical</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">)</span>

<span class="c">## print detail of data</span>
<span class="k">print</span><span class="p">(</span><span class="s">'x_train shape:</span><span class="se">\t</span><span class="s">'</span><span class="p">,</span> <span class="n">x_train</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">x_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">'train samples'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">x_test</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">'test samples'</span><span class="p">)</span>
</code></pre></div></div>

<p>Định nghĩa một CNN model với 2 convolutional layers và một fully connected layer.</p>
<p align="center">
  <img src="https://lh3.googleusercontent.com/BFeC6fiSjGFrVXMrc_BfJKWCIKkwnh56FoJsziY8T6h4BPM55TSPjUwxpBomKrDUR49BMfdvVM94OGBq8hXEwAW2Pg_qqv7DzfFCweXkGuwqqcJrmLIZmWa-vk-_6eHAD6_jOc5LPN8cPiy33HWCpEiqvyBl7MLV813TAKJOMsgPMBsJ1aSk3UTAJnEC8NfLyrTfDPu4odStNnuTPkRxu47hFp3lbFD7PKKnZcDcAxL9q580ywan5uBpPYev0QV0P2UVZ2cc93o0Uyb_Co9SVhV6eMQeJMeQlv_6aKOHFmBhzvkDK3SxweXY8uBCDIBio6pIkkifsa26f_sYoqWc9ym9Uqcs0BPXzUDM44_6Ilzevh-Hhw5o12Filmh6bBpbe6pPe0-sgUeLQHqxL0DpRZvvLFT2DITGdkJMhAAUtUpzPkV1hgzybN5eODZ_pw6jAtsK7jBw4WpAfLTGYqlWANzU9bMXjt2GUqOuOzvD8IsUWflRAI57ef9GWnH0WgIifMLYaX9ncXiNdYET7wm1u4bHew5sbpzsoQ8_VyCrI-A3geEgQJbDjenavKpNY1psqHypQhpqBJk5hWAy_1LHWcZIe3lTzsT69xZJYIPVtwKjKBPVejxWGkifkkS0bD6M12zsJzMzHEYtvNFyez5kC-dpdZUTqh3W=w1725-h572-no" />
  </p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># define CNN (LeNet)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">Sequential</span><span class="p">()</span>

<span class="c">## layer 1</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="n">kernel_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">activation</span> <span class="o">=</span> <span class="s">'relu'</span><span class="p">,</span> <span class="n">input_shape</span> <span class="o">=</span> <span class="n">input_shape</span><span class="p">))</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">MaxPooling2D</span><span class="p">(</span><span class="n">pool_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>

<span class="c">## layer 2</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">activation</span> <span class="o">=</span> <span class="s">'relu'</span><span class="p">))</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">MaxPooling2D</span><span class="p">(</span><span class="n">pool_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>

<span class="c">## FC layer</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Flatten</span><span class="p">())</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dense</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">activation</span> <span class="o">=</span> <span class="s">'relu'</span><span class="p">))</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dense</span><span class="p">(</span><span class="n">num_classes</span><span class="p">,</span> <span class="n">activation</span> <span class="o">=</span> <span class="s">'softmax'</span><span class="p">))</span>
</code></pre></div></div>

<p>Định nghĩa hàm mất mát cross-entropy và dùng Adam optimizer, ngoài Adam chúng ta cũng có thể dùng SGD (Stochastic gradient descent).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">model</span><span class="o">.</span><span class="nb">compile</span><span class="p">(</span><span class="n">loss</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">losses</span><span class="o">.</span><span class="n">categorical_crossentropy</span><span class="p">,</span> 
        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">optimizers</span><span class="o">.</span><span class="n">Adam</span><span class="p">(),</span> <span class="n">metrics</span> <span class="o">=</span> <span class="p">[</span><span class="s">'accuracy'</span><span class="p">])</span>
</code></pre></div></div>

<p>Tiếp theo là bước training model:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># training model</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span><span class="p">,</span>
        <span class="n">epochs</span> <span class="o">=</span> <span class="n">epochs</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">validation_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">),</span>
        <span class="n">callbacks</span> <span class="o">=</span> <span class="p">[</span><span class="n">history</span><span class="p">])</span>
</code></pre></div></div>
<p>Test model</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># logging metrics</span>
<span class="k">class</span> <span class="nc">AccuracyHistory</span><span class="p">(</span><span class="n">keras</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">Callback</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">on_train_begin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logs</span> <span class="o">=</span> <span class="p">{}):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acc</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">on_epoch_end</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">logs</span> <span class="o">=</span> <span class="p">{}):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">logs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'acc'</span><span class="p">))</span>

<span class="n">history</span> <span class="o">=</span> <span class="n">AccuracyHistory</span><span class="p">()</span>

<span class="c"># test model</span>
<span class="n">score</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c"># show performance</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Test loss:'</span><span class="p">,</span> <span class="n">score</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Test accuracy:'</span><span class="p">,</span> <span class="n">score</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span> <span class="n">history</span><span class="o">.</span><span class="n">acc</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Epochs'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'Accuracy'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>
<p>Kết quả cho thấy mô hình đạt độ chính xác khá cao chỉ sau 10 lần training (91.66%). Ta có thể so sánh với một số classifier khác tại <a href="http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/">Fashion-MNIST Benchmark</a></p>

<p align="center">
  <img src="https://lh3.googleusercontent.com/2l2jM92Rs6sr8_5KRRZ_Vil8xfr8bTBseJKArBrSrdLYoI6ITHYAOO1Z-6xIEu-HPoPqCSFFJTIu2j9MnD0ElSKkte97ZrRlB6nTJE6VcZbZPzQqeO3qjTM5Fyw2uPQ4sdcBHkMNOHh18kcSCBEQPhL6wVPFKC76DL6rvhPA6M_DtkpFmZHeqopUVeOERcJhDsvV9Ha6eKXUasmfNkxpq9XU79MoNe-qdxz7bPF8XAa7mUX80qtWwPZLttdluoB9KnL4RhFnBJwyEdlMf6BCb_Dn6vatve22iNQCVaX98-SgdMJtdn0HSZ93SctdI_e9M6vIRPwrSElxeCYLg2gz6T6oQbU4QBR6Y_jcYckM-cjZY6UVSqJrd3yDRpV1DiuN582Gzv0KH7bwwYO2RTRhx16_y6vFhph-BD6S9axh8yO0UOyvHmghH4u6isOOsHbumU4J7GUJVK-nFg7lW_9ksjlQ4vTiDOW9bXTD7JJkZk7Ld2iKyRah7R6eJ0YLZXfJWgtkTcqaNjRywFblaLEoaHC0FceuR729gceguHLtSWpGHJNGEnfI6hSzc8FNCTLQlq_lC8LrwVK3px51hFrDbamCojyC8xErqSS-kY_IlPhMOzIQDeqQMt7db5A9kkmmI8bXwxOrDIxT3jqzzEmIc5NArRBrVwA-=w640-h480-no" />
  </p>

<p align="center">
  <img src="https://lh3.googleusercontent.com/4-xzGP56vXcsEGyca6MC1u2ZMq-_s-mXTMlWmRT5HLaBiiJ_TgxWcaxRMRu39gwGKxufuc830pX8zqBJ7zerceIOCPVKXFaIZ_YKg8wMohUBWFScMQeAHWBY4w5443TQGMVBjgNj1zJz3ZdLLBKQzzuSdrwtZLhwpOZGHC0R9w0iQyoZg4G2WHQuDsPW4BklI4XexItA3zBj3UG7w2ZQCdkGfb-gaHsQVqPkg0jfzSH-GUn-VZwmygDk6GQaoZWXW1XgnwAFWyAWoEFr8v21nUvZFp5TSF0XudlHWM9Cegh-1SNecQCcgzEcOyVf2AE42EGpFZxLHYgv-cN3Na7QkGSu90cxeQOloOZeBC4Y3JO_0gbN7nh1dX2aBwJaiApKzn0Poh-cpwFVLFj7WeNvqgJoS8FU_pMB31LKvequcVBGE-71EatJCCGPecHHaws9U_h1Zgp1vXLz4g33b7NN1ca4K7mJqDzLOLf8fWND9hYFAazFz8XK3uTdra0_RzYcP8tRxf01Jyrq2dO8-AqsqwQvXgYBQdguWgObQxFkEumcOSDKO7SFgV8NNkp_GMHTMuyvzNS5C05_VUWffj5-FsCTmRjt2PKneUoSsZ_lcQM0pBjvH7FW3_UViRulZsXpJCPpvXJbaz26sD0qabTjnRVWtnD0a0a5=w652-h386-no" />
  </p>

<h2 id="source-code">Source code</h2>

<ul>
  <li><a href="https://gitlab.com/hdi-superuser/deep-learning/blob/master/keras_cnn.py">Keras CNN</a></li>
</ul>

<h2 id="tài-liệu-tham-khảo">Tài liệu tham khảo</h2>
<ul>
  <li>
    <p><a href="https://ujjwalkarn.me/2016/08/11/intuitive-explanation-convnets/">An Intuitive Explanation of Convolutional Neural Networks</a></p>
  </li>
  <li>
    <p><a href="http://cs231n.github.io/convolutional-networks/">CS231n Convolutional Neural Networks for Visual Recognition: ConvNets Note</a></p>
  </li>
  <li>
    <p><a href="https://medium.com/@RaghavPrabhu/understanding-of-convolutional-neural-network-cnn-deep-learning-99760835f148">Understanding of Convolutional Neural Network (CNN) — Deep Learning</a></p>
  </li>
  <li>
    <p><a href="https://adeshpande3.github.io/A-Beginner%27s-Guide-To-Understanding-Convolutional-Neural-Networks/">A Beginner’s Guide To Understanding Convolutional Neural Networks</a></p>
  </li>
  <li>
    <p><a href="http://adventuresinmachinelearning.com/keras-tutorial-cnn-11-lines/">Keras tutorial – build a convolutional neural network in 11 lines</a></p>
  </li>
</ul>
</div>

  <footer class="article__footer"><meta itemprop="dateModified" content="2018-07-27T02:57:18+07:00"><!-- this will show at every article content's bottom --><div class="article__license"><div class="license">
    <p>This work is licensed under a <a itemprop="license" rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/">Attribution-NonCommercial 4.0 International</a> license.
      <a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/">
        <img alt="Attribution-NonCommercial 4.0 International" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" />
      </a>
    </p>
  </div></div></footer><div class="article__section-navigator clearfix"><div class="previous"><span>PREVIOUS</span><a href="/2018/07/01/welcome.html">Welcome</a></div><div class="next"><span>NEXT</span><a href="/news/2018/09/21/no-dark-corner-in-china.html">[NEWS] Hệ thống giám sát công nghệ cao của Trung Quốc</a></div></div></div>

<div class="just-comments"data-apikey="2fc5aa95-0f8e-4741-a9e8-e644867569db">
    </div>
    <script async src="https://just-comments.com/w.js"></script>
    
<script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    $(function() {
      var $this ,$scroll;
      var $articleContent = $('.js-article-content');
      var hasSidebar = $('.js-page-root').hasClass('layout--page--sidebar');
      var scroll = hasSidebar ? '.js-page-main' : 'html, body';
      $scroll = $(scroll);

      $articleContent.find('.highlight').each(function() {
        $this = $(this);
        $this.attr('data-lang', $this.find('code').attr('data-lang'));
      });
      $articleContent.find('h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]').each(function() {
        $this = $(this);
        $this.append($('<a class="anchor" aria-hidden="true"></a>').html('<i class="fas fa-anchor"></i>'));
      });
      $articleContent.on('click', '.anchor', function() {
        $scroll.scrollToAnchor('#' + $(this).parent().attr('id'), 400);
      });
    });
  });
})();</script></div></article>
            </div>
          </div></div></div>

      <div class="page__footer">
<div class="footer js-page-footer">
  <div class="main"><aside  itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Duy V. Huynh"><meta itemprop="url" content="https://vndee.github.io"><meta itemprop="description" content="I am a normal guy, a dreamer, a reader and a computer science enthusiast."><div class="footer__author-links"><div class="author-links">
  <ul class="menu menu--nowrap menu--inline"><link itemprop="url" href="https://vndee.github.io"><li title="Follow me on Facebook.">
        <a class="button button--circle facebook-button" itemprop="sameAs" href="https://www.facebook.com/huynhduy.idol" target="_blank">
          <div class="icon"><svg fill="#000000" width="24px" height="24px" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M767.428571 6.857143l0 150.857143-89.714286 0q-49.142857 0-66.285714 20.571429t-17.142857 61.714286l0 108 167.428571 0-22.285714 169.142857-145.142857 0 0 433.714286-174.857143 0 0-433.714286-145.714286 0 0-169.142857 145.714286 0 0-124.571429q0-106.285714 59.428571-164.857143t158.285714-58.571429q84 0 130.285714 6.857143z" />
</svg></div>
        </a>
      </li><li title="Follow me on Twitter.">
        <a class="button button--circle twitter-button" itemprop="sameAs" href="https://twitter.com/huynhduy_idol" target="_blank">
          <div class="icon"><svg fill="#000000" width="24px" height="24px" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M1024.032 194.432c-37.664 16.704-78.176 28-120.672 33.088 43.36-26.016 76.672-67.168 92.384-116.224-40.608 24.064-85.568 41.568-133.408 50.976-38.336-40.832-92.928-66.336-153.344-66.336-116.032 0-210.08 94.048-210.08 210.08 0 16.48 1.856 32.512 5.44 47.872-174.592-8.768-329.408-92.416-433.024-219.52-18.08 31.04-28.448 67.104-28.448 105.632 0 72.896 37.088 137.184 93.472 174.88-34.432-1.088-66.816-10.528-95.168-26.272-0.032 0.864-0.032 1.76-0.032 2.656 0 101.792 72.416 186.688 168.512 205.984-17.632 4.8-36.192 7.36-55.36 7.36-13.536 0-26.688-1.312-39.52-3.776 26.72 83.456 104.32 144.192 196.256 145.888-71.904 56.352-162.496 89.92-260.928 89.92-16.96 0-33.664-0.992-50.112-2.944 92.96 59.616 203.392 94.4 322.048 94.4 386.432 0 597.728-320.128 597.728-597.76 0-9.12-0.192-18.176-0.608-27.168 41.056-29.632 76.672-66.624 104.832-108.736z" />
</svg>
</div>
        </a>
      </li><li title="Follow me on Github.">
        <a class="button button--circle github-button" itemprop="sameAs" href="https://github.com/vndee" target="_blank">
          <div class="icon"><svg fill="#000000" width="24px" height="24px" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path class="svgpath" data-index="path_0" fill="#272636" d="M0 525.2c0 223.6 143.3 413.7 343 483.5 26.9 6.8 22.8-12.4 22.8-25.4l0-88.7c-155.3 18.2-161.5-84.6-172-101.7-21.1-36-70.8-45.2-56-62.3 35.4-18.2 71.4 4.6 113.1 66.3 30.2 44.7 89.1 37.2 119 29.7 6.5-26.9 20.5-50.9 39.7-69.6C248.8 728.2 181.7 630 181.7 513.2c0-56.6 18.7-108.7 55.3-150.7-23.3-69.3 2.2-128.5 5.6-137.3 66.5-6 135.5 47.6 140.9 51.8 37.8-10.2 80.9-15.6 129.1-15.6 48.5 0 91.8 5.6 129.8 15.9 12.9-9.8 77-55.8 138.8-50.2 3.3 8.8 28.2 66.7 6.3 135 37.1 42.1 56 94.6 56 151.4 0 117-67.5 215.3-228.8 243.7 26.9 26.6 43.6 63.4 43.6 104.2l0 128.8c0.9 10.3 0 20.5 17.2 20.5C878.1 942.4 1024 750.9 1024 525.3c0-282.9-229.3-512-512-512C229.1 13.2 0 242.3 0 525.2L0 525.2z" />
</svg>
</div>
        </a>
      </li></ul>
</div>
</div>
    </aside>
    <footer class="site-info"><p class="menu menu--center">
        <span>© the INFINITY. 2018</span>
        <a type="application/rss+xml" href="/feed.xml">RSS</a>
      </p>
      <p>Powered by <a title="Jekyll is a simple, blog-aware, static site generator." href="http://jekyllrb.com/">Jekyll</a> & <a
        title="TeXt is a succinct theme for blogging." href="https://github.com/kitian616/jekyll-TeXt-theme">TeXt Theme</a>.
      </p>
    </footer>
  </div>
</div></div>
    </div>
  </div><div class="page__search-panel"><div class="search">
  <div class="main">
    <div class="search__header">Search</div>
    <div class="search-bar">
      <div class="search-box js-search-box">
        <div class="search-box__icon-search"><i class="fas fa-search"></i></div>
        <input type="text" />
        <div class="search-box__icon-clear js-icon-clear">
          <a><i class="fas fa-times"></i></a>
        </div>
      </div>
      <button class="button button--secondary button--pill search__cancel js-search-toggle">
        Cancel</button>
    </div>
    <div class="search-result js-search-result"></div>
  </div>
</div>

<script>var SOURCES = window.TEXT_VARIABLES.sources;
var PAHTS = window.TEXT_VARIABLES.paths;
window.Lazyload.js([SOURCES.jquery, PAHTS.search_js], function() {
  var searchData = window.TEXT_SEARCH_DATA ? initData(window.TEXT_SEARCH_DATA) : {};

  function memorize(f) {
    var cache = {};
    return function () {
      var key = Array.prototype.join.call(arguments, ',');
      if (key in cache) return cache[key];
      else return cache[key] = f.apply(this, arguments);
    };
  }

  function initData(data) {
    var _data = [], i, j, key, keys, cur;
    keys = Object.keys(data);
    for (i = 0; i < keys.length; i++) {
      key = keys[i], _data[key] = [];
      for (j = 0; j < data[key].length; j++) {
        cur = data[key][j];
        cur.title = window.decodeUrl(cur.title);
        cur.url = window.decodeUrl(cur.url);
        _data[key].push(cur);
      }
    }
    return _data;
  }

  /// search
  function searchByQuery(query) {
    var i, j, key, keys, cur, _title, result = {};
    keys = Object.keys(searchData);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      for (j = 0; j < searchData[key].length; j++) {
        cur = searchData[key][j], _title = cur.title;
        if ((result[key] === undefined || result[key] && result[key].length < 4 )
          && _title.toLowerCase().indexOf(query.toLowerCase()) >= 0) {
          if (result[key] === undefined) {
            result[key] = [];
          }
          result[key].push(cur);
        }
      }
    }
    return result;
  }

  var renderHeader = memorize(function(header) {
    return $('<p class="search-result__header">' + header + '</p>');
  });

  var renderItem = function(index, title, url) {
    return $('<li class="search-result__item" data-index="' + index + '"><a class="button" href="' + url + '">' + title + '</a></li>');
  };

  function render(data) {
    if (!data) {
      return null;
    }
    var $root = $('<ul></ul>'), i, j, key, keys, cur, itemIndex = 0;
    keys = Object.keys(data);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      $root.append(renderHeader(key));
      for (j = 0; j < data[key].length; j++) {
        cur = data[key][j];
        $root.append(renderItem(itemIndex++, cur.title, cur.url));
      }
    }
    return $root;
  }

  // search box
  var $searchBox = $('.js-search-box');
  var $searchInput = $searchBox.children('input');
  var $searchClear = $searchBox.children('.js-icon-clear');
  var $result = $('.js-search-result'), $resultItems;
  var lastActiveIndex, activeIndex;

  function searchBoxEmpty() {
    $searchBox.removeClass('not-empty'); $result.html(null);
    $resultItems = $('.search-result__item'); activeIndex = 0;
  }

  $searchInput.on('input', window.throttle(function() {
    var val = $(this).val();
    if (val === '' || typeof val !== 'string') {
      searchBoxEmpty();
    } else {
      $searchBox.addClass('not-empty'); $result.html(render(searchByQuery(val)));
      $resultItems = $('.search-result__item'); activeIndex = 0;
      $resultItems.eq(0).addClass('active');
    }
  }, 400));
  $searchInput.on('focus', function() {
    $(this).addClass('focus');
  });
  $searchInput.on('blur', function() {
    $(this).removeClass('focus');
  });
  $searchClear.on('click', function() {
    $searchInput.val(''); searchBoxEmpty();
  });

  // search panel
  var $pageRoot = $('.js-page-root');
  var $searchToggle = $('.js-search-toggle');
  var showSearch = false;

  function closeSearchPanel() {
    $pageRoot.removeClass('show-search-panel');
    $searchInput[0].blur();
    setTimeout(function() {
      $searchInput.val(''); searchBoxEmpty();
      window.pageAsideAffix && window.pageAsideAffix.refresh();
    }, 400);
  }
  function openSearchPanel() {
    $pageRoot.addClass('show-search-panel');
    $searchInput[0].focus();
  }

  // Char Code: 13  Enter, 27  ESC, 37  ⬅, 38  ⬆, 39  ➡, 40  ⬇, 83  S, 191 /
  function isFormElement(e) {
    var tagName = e.target.tagName || e.srcElement.tagName;
    return tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA';
  }
  function charCodeFilter(e) {
    return e.target === $searchInput[0] && (e.which === 13 || e.which === 27 || e.which === 38 || e.which === 40);
  }

  function updateResultItems() {
    lastActiveIndex >= 0 && $resultItems.eq(lastActiveIndex).removeClass('active');
    activeIndex >= 0 && $resultItems.eq(activeIndex).addClass('active');
  }

  function moveActiveIndex(direction) {
    var itemsCount = $resultItems ? $resultItems.length : 0;
    if (itemsCount > 1) {
      lastActiveIndex = activeIndex;
      if (direction === 'up') {
        activeIndex = (activeIndex - 1 + itemsCount) % itemsCount;
      } else if (direction === 'down') {
        activeIndex = (activeIndex + 1 + itemsCount) % itemsCount;
      }
      updateResultItems();
    }
  }

  $(document).on('keyup', function(e) {
    if (!isFormElement(e) || charCodeFilter(e)) {
      if (e.which === 83 || e.which === 191) {
        showSearch || (showSearch = true, openSearchPanel());
      } else if (e.which ===  27) {
        showSearch && (showSearch = false, closeSearchPanel());
      } else if (e.which === 38) {
        showSearch && moveActiveIndex('up');
      } else if (e.which === 40) {
        showSearch && moveActiveIndex('down');
      } else if (e.which === 13) {
        showSearch && $resultItems && activeIndex >= 0 && $resultItems.eq(activeIndex).children('a')[0].click();
      }
    }
  });

  $result.on('mouseover', '.search-result__item > a', function() {
    var itemIndex = $(this).parent().data('index');
    itemIndex >= 0 && (lastActiveIndex = activeIndex, activeIndex = itemIndex, updateResultItems());
  });

  $searchToggle.on('click', function() {
    showSearch = !showSearch;
    showSearch ? openSearchPanel() : closeSearchPanel();
  });
});</script></div></div>


<script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function scrollToAnchor(anchor, duration, callback) {
      var $root = this;
      $root.animate({ scrollTop: $(anchor).position().top }, duration, function() {
        window.history.replaceState(null, '', window.location.href.split('#')[0] + anchor);
        callback && callback();
      });
    }
    $.fn.scrollToAnchor = scrollToAnchor;
  });
})();(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $window = $(window), $root, $scrollTarget, $scroller, $scroll;
    var rootTop, rootLeft, rootHeight, scrollBottom, rootBottomTop;
    var offsetBottom = 0, disabled = false, scrollTarget = window, scroller = 'html, body', scroll = window.document;
    var hasInit = false, isOverallScroller = true, curState;

    function setOptions(options) {
      var _options = options || {};
      _options.offsetBottom && (offsetBottom = _options.offsetBottom);
      _options.scrollTarget && (scrollTarget = _options.scrollTarget);
      _options.scroller && (scroller = _options.scroller);
      _options.scroll && (scroll = _options.scroll);
      _options.disabled !== undefined && (disabled = _options.disabled);
      $scrollTarget = $(scrollTarget);
      $scroller = $(scroller);
      isOverallScroller = window.isOverallScroller($scrollTarget[0]);
      $scroll = $(scroll);
    }
    function initData() {
      top();
      rootHeight = $root.outerHeight();
      rootTop = $root.offset().top + (isOverallScroller ? 0 :  $scrollTarget.scrollTop());
      rootLeft = $root.offset().left;
    }
    function calc(needInitData) {
      needInitData && initData();
      scrollBottom = $scroll.outerHeight() - offsetBottom - rootHeight;
      rootBottomTop = scrollBottom - rootTop;
    }
    function top() {
      if (curState !== 'top') {
        $root.removeClass('fixed').css({
          left: 0,
          top: 0
        });
        curState = 'top';
      }
    }
    function fixed() {
      if (curState !== 'fixed') {
        $root.addClass('fixed').css({
          left: rootLeft + 'px',
          top: 0
        });
        curState = 'fixed';
      }
    }
    function bottom() {
      if (curState !== 'bottom') {
        $root.removeClass('fixed').css({
          left: 0,
          top: rootBottomTop + 'px'
        });
        curState = 'bottom';
      }
    }
    function setState() {
      var scrollTop = $scrollTarget.scrollTop();
      if (scrollTop >= rootTop && scrollTop <= scrollBottom) {
        fixed();
      } else if (scrollTop < rootTop) {
        top();
      } else {
        bottom();
      }
    }
    function init() {
      if(!hasInit) {
        var interval, timeout;
        calc(true); setState();
        // run calc every 100 millisecond
        interval = setInterval(function() {
          calc();
        }, 100);
        timeout = setTimeout(function() {
          clearInterval(interval);
        }, 45000);
        window.pageLoad.then(function() {
          setTimeout(function() {
            clearInterval(interval);
            clearTimeout(timeout);
          }, 3000);
        });
        $scrollTarget.on('scroll', function() {
          disabled || setState();
        });
        $window.on('resize', function() {
          disabled || (calc(true), setState());
        });
        hasInit = true;
      }
    }

    function affix(options) {
      $root = this;
      setOptions(options);
      if (!disabled) {
        init();
      }
      $window.on('resize', window.throttle(function() {
        init();
      }, 200));
      return {
        setOptions: setOptions,
        refresh: function() {
          calc(true); setState();
        }
      };
    }
    $.fn.affix = affix;
  });
})();(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $window = $(window), $root, $scrollTarget, $scroller, $tocUl = $('<ul class="toc"></ul>'), $tocLi, $headings, $activeLast, $activeCur;
    var selectors = 'h1,h2,h3', container = 'body', scrollTarget = window, scroller = 'html, body', disabled = false;
    var headingsPos, scrolling = false, rendered = false, hasInit = false;
    function setOptions(options) {
      var _options = options || {};
      _options.selectors && (selectors = _options.selectors);
      _options.container && (container = _options.container);
      _options.scrollTarget && (scrollTarget = _options.scrollTarget);
      _options.scroller && (scroller = _options.scroller);
      _options.disabled !== undefined && (disabled = _options.disabled);
      $headings = $(container).find(selectors).filter('[id]');
      $scrollTarget = $(scrollTarget);
      $scroller = $(scroller);
    }
    function calc() {
      headingsPos = [];
      $headings.each(function() {
        headingsPos.push(Math.floor($(this).position().top));
      });
    }
    function setState(element, disabled) {
      var scrollTop = $scrollTarget.scrollTop(), i;
      if (disabled || !headingsPos || headingsPos.length < 1) { return; }
      if (element) {
        $activeCur = element;
      } else {
        for (i = 0; i < headingsPos.length; i++) {
          if (scrollTop >= headingsPos[i]) {
            $activeCur = $tocLi.eq(i);
          } else {
            $activeCur || ($activeCur = $tocLi.eq(i));
            break;
          }
        }
      }
      $activeLast && $activeLast.removeClass('active');
      ($activeLast = $activeCur).addClass('active');
    }
    function render() {
      if(!rendered) {
        $root.append($tocUl);
        $headings.each(function() {
          var $this = $(this);
          $tocUl.append($('<li></li>').addClass('toc-' + $this.prop('tagName').toLowerCase())
            .append($('<a></a>').text($this.text()).attr('href', '#' + $this.prop('id'))));
        });
        $tocLi = $tocUl.children('li');
        $tocUl.on('click', 'a', function(e) {
          e.preventDefault();
          var $this = $(this);
          scrolling = true;
          setState($this.parent());
          $scroller.scrollToAnchor($this.attr('href'), 400, function() {
            scrolling = false;
          });
        });
      }
      rendered = true;
    }
    function init() {
      var interval, timeout;
      if(!hasInit) {
        render(); calc(); setState(null, scrolling);
        // run calc every 100 millisecond
        interval = setInterval(function() {
          calc();
        }, 100);
        timeout = setTimeout(function() {
          clearInterval(interval);
        }, 45000);
        window.pageLoad.then(function() {
          setTimeout(function() {
            clearInterval(interval);
            clearTimeout(timeout);
          }, 3000);
        });
        $scrollTarget.on('scroll', function() {
          disabled || setState(null, scrolling);
        });
        $window.on('resize', window.throttle(function() {
          if (!disabled) {
            render(); calc(); setState(null, scrolling);
          }
        }, 100));
      }
      hasInit = true;
    }
    function toc(options) {
      $root = this;
      setOptions(options);
      if (!disabled) {
        init();
      }
      $window.on('resize', window.throttle(function() {
        init();
      }, 200));
      return {
        setOptions: setOptions
      };
    }
    $.fn.toc = toc;
  });
})();/*(function () {

})();*/</script><script>
  /* toc must before affix, since affix need to konw toc' height. */(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  var TOC_SELECTOR = window.TEXT_VARIABLES.site.toc.selectors;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $window = $(window);
    var $articleContent = $('.js-article-content');
    var $tocRoot = $('.js-toc-root'), $col2 = $('.js-col-aside');
    var toc;
    var tocDisabled = false;
    var hasSidebar = $('.js-page-root').hasClass('layout--page--sidebar');
    var hasToc = $articleContent.find(TOC_SELECTOR).length > 0;

    function disabled() {
      return $col2.css('display') === 'none' || !hasToc;
    }

    tocDisabled = disabled();

    toc = $tocRoot.toc({
      selectors: TOC_SELECTOR,
      container: $articleContent,
      scrollTarget: hasSidebar ? '.js-page-main' : null,
      scroller: hasSidebar ? '.js-page-main' : null,
      disabled: tocDisabled
    });

    $window.on('resize', window.throttle(function() {
      tocDisabled = disabled();
      toc && toc.setOptions({
        disabled: tocDisabled
      });
    }, 100));

  });
})();(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $window = $(window), $pageFooter = $('.js-page-footer');
    var $pageAside = $('.js-page-aside');
    var affix;
    var tocDisabled = false;
    var hasSidebar = $('.js-page-root').hasClass('layout--page--sidebar');

    affix = $pageAside.affix({
      offsetBottom: $pageFooter.outerHeight(),
      scrollTarget: hasSidebar ? '.js-page-main' : null,
      scroller: hasSidebar ? '.js-page-main' : null,
      scroll: hasSidebar ? $('.js-page-main').children() : null,
      disabled: tocDisabled
    });

    $window.on('resize', window.throttle(function() {
      affix && affix.setOptions({
        disabled: tocDisabled
      });
    }, 100));

    window.pageAsideAffix = affix;
  });
})();</script><script type="text/x-mathjax-config">
	var _config = { tex2jax: {
		inlineMath: [['$','$'], ['\\(','\\)']]
	}};MathJax.Hub.Config(_config);
</script>
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
    </div>
    <script>(function () {
  var $root = document.getElementsByClassName('root')[0];
  if (window.hasEvent('touchstart')) {
    $root.dataset.isTouch = true;
    document.addEventListener('touchstart', function(){}, false);
  }
})();</script>
  </body>
</html>